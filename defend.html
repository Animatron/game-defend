<!DOCTYPE html>
<html>
	<head>
		<title>Tower Defense - Animatron HTML5 Player Demo</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<script src="../player/vendor/matrix.js" type="text/javascript"></script>
		<script src="../player/anm.player.js" type="text/javascript"></script>
        <script src="../player/anm.collisions.js" type="text/javascript"></script>
		<script src="../player/anm.builder.js" type="text/javascript"></script>
		<script src="../player/animatron_import.js" type="text/javascript"></script>

		<script type="text/javascript">
			var b = Builder._$, B = Builder, C = anm.C;
			
			// canvas
			var width = 640;
			var height = 480;
			var scene1 = b();
			
			var precision = 16;
			
			var spawn = [400, 400];
			var target = [0, 0];
			
			var path;
			
			function Rectangle(x1, y1, x2, y2) {
				this.x1 = x1;
				this.y1 = y1;
				this.x2 = x2;
				this.y2 = y2;
			}
			
			var block = [new Rectangle(48, 0, 128, 160)]; // this will be preset, arrays of rectangles
			var enemy = new Array();
			var turret = new Array();
			var grid = new Array(); // height vs width
			
			// create grid
			grid = new Array(height/precision);
			for (var i=0; i<height/precision; i++) {
				grid[i] = new Array(width/precision);
				for (var j=0; j<width/precision; j++)
					grid[i][j] = 0;
			}
			// fill with blocks
			for (var i=0; i<block.length; i++) {
				var k = block[i];
				for (var y=k.y1/precision; y<k.y2/precision; y++) {
					for (var x=k.x1/precision; x<k.x2/precision; x++)
						grid[y][x] = 1;
				}
			}
			
			// A* implementation based on http://webreflection.blogspot.com/2006/10/javascript-path-finder-with-star.html
			
			function successors(x, y, rows, cols){
				var
					N = y - 1,
					S = y + 1,
					E = x + 1,
					W = x - 1,
					$N = N > -1 && !grid[N][x],
					$S = S < rows && !grid[S][x],
					$E = E < cols && !grid[y][E],
					$W = W > -1 && !grid[y][W],
					result = [],
					i = 0
				;
				$N && (result[i++] = {x:x, y:N});
				$E && (result[i++] = {x:E, y:y});
				$S && (result[i++] = {x:x, y:S});
				$W && (result[i++] = {x:W, y:y});
				return result;
			}
			
			function distanceTo(start, end) {
				// divide weight by turret distance
				var risk = 0;
				if (turret.length > 0)
				for (var i=0; i<turret.length; i++) {
					var d = turret[i].data();
					risk += Math.sqrt(Math.pow(end.x - d.x, 2) + Math.pow(end.y - d.y, 2));
				}
				//console.log(turret.length, start.x, start.y, end.x, end.y, risk);
        		return (Math.abs(start.x - end.x) + Math.abs(start.y - end.y)) / (risk+1);
    		}
					
			function AStar(start, end) {
				var
					cols = grid[0].length,
					rows = grid.length,
					limit = cols * rows,
					list = {},
					result = [],
					open = [{x:start[0], y:start[1], f:0, g:0, v:start[0]+start[1]*cols}],
					length = 1,
					adj, distance, i, j, max, min, current, next
				;
				end = {x:end[0], y:end[1], v:end[0]+end[1]*cols};
				
				do {
					max = limit;
					min = 0;
					for(i = 0; i < length; ++i) {
						if((f = open[i].f) < max) {
							max = f;
							min = i;
						}
					};
					current = open.splice(min, 1)[0];
					if (current.v != end.v) {
						--length;
						next = successors(current.x, current.y, grid, rows, cols);
						for(i = 0, j = next.length; i < j; ++i){
							(adj = next[i]).p = current;
							adj.f = adj.g = 0;
							adj.v = adj.x + adj.y * cols;
							if(!(adj.v in list)){
								adj.f = (adj.g = current.g + distanceTo(adj, current)) + distanceTo(adj, end);
								open[length++] = adj;
								list[adj.v] = 1;
							}
						}
					} else {
						i = length = 0;
						do {
							result[i++] = [current.x, current.y];
						} while (current = current.p);
						result.reverse();
					}
				} while (length);
				return result;
			}
			
			var boxModifier = function(t) {
				var speed = 1;
				var x = b(this.$).data().x;
				var y = b(this.$).data().y;
				var index = b(this.$).data().i + speed/precision;
				var p = b(this.$).data().path;
				var i = Math.ceil(index);
				if (i < p.length) {
					var xdif = p[i][0]*precision - x;
					var ydif = p[i][1]*precision - y;
					this.x = x + (xdif < 0 ? -1 : xdif > 0 ? 1 : 0)*speed;
					this.y = y + (ydif < 0 ? -1 : ydif > 0 ? 1 : 0)*speed;
					b(this.$).data({'x':this.x, 'y':this.y, 'i':index, 'path':p});
					//console.log(index, this.x, this.y);
				}
			}
			
			var turretModifier = function(t) {
				var d = b(this.$).data();
				if (Math.floor(t) != Math.floor(d.t) && enemy.length > 0) {
					// find nearest
					var e;
					var f = width * height * width * height;
					for (var i=0; i<enemy.length; i++) {
						var g = Math.pow(enemy[i].data().x - d.x, 2) + Math.pow(enemy[i].data().y - d.y, 2);
						if (g < f) {
							f = g;
							e = enemy[i];
						}
					}
					var a = Math.atan2(e.data().y - d.y, e.data().x - d.x);
					scene1.add(initBullet(d.x, d.y, Math.cos(a), Math.sin(a)));
				}
				b(this.$).data({'x':d.x, 'y':d.y, 'level':0, 't':t});
			}
			
			var bulletModifier = function(t) {
				var d = b(this.$).data();
				this.x = d.x + d.vx;
				this.y = d.y + d.vy;
				for (var i=0; i<enemy.length; i++) {
					if (this.$.intersects(enemy[i].v)) {
						// TODO: remove this
						scene1.remove(this.$);
						// TODO: damage other
						//console.log("hit");
					}
				}
				b(this.$).data({'x':this.x, 'y':this.y, 'vx':d.vx, 'vy':d.vy, 'damage':d.damage});
			}
			
			function initEnemy(xi, yi) {
				var t = b().rect([precision/2, precision/2], [precision, precision]).fill('#000').data({'x':xi, 'y':yi, 'hp':3, 'path':path, 'i':0}).modify(boxModifier);
				enemy.push(t);
				return t;
			}
			
			function initTurret(xi, yi) {
				var x = Math.round(xi/precision)*precision;
				var y = Math.round(yi/precision)*precision;
				var t = b().circle([x, y], precision/2).fill('#f00').nostroke().data({'x':x, 'y':y, 'level':0, 't':0}).modify(turretModifier);
				turret.push(t);
				return t;
			}
			
			function initBullet(xi, yi, vx, vy) {
				var t = b().circle([0, 0], 2).fill('#00f').nostroke().data({'x':xi, 'y':yi, 'vx':vx, 'vy':vy, 'damage':0}).modify(bulletModifier);
				return t;
			}
			
            function start() {
				path = AStar([Math.floor(spawn[0]/precision), Math.floor(spawn[1]/precision)], target);
				scene1.add(initEnemy(spawn[0], spawn[1]));
				
				scene1.on(C.X_MCLICK, function(evt) {
					scene1.add(initTurret(evt.pos[0], evt.pos[1]));
					path = AStar([Math.floor(spawn[0]/precision), Math.floor(spawn[1]/precision)], target);
					
					scene1.add(initEnemy(spawn[0], spawn[1]));
				});
				
				createPlayer('canvas', {'mode': C.M_DYNAMIC}).load(scene1).play();
            }
        </script>
      </head>

	<body onload="start();">
		<h1>Tower Defense - Animatron HTML5 Player Demo</h1>

		<!-- canvases -->
		<canvas id="canvas" width="640" height="480"></canvas>

	</body>

</html>