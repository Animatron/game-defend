<!DOCTYPE html>
<html>
	<head>
		<title>Tower Defense - Animatron HTML5 Player Demo</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<script src="../player/vendor/matrix.js" type="text/javascript"></script>
		<script src="../player/anm.player.js" type="text/javascript"></script>
        <script src="../player/anm.collisions.js" type="text/javascript"></script>
		<script src="../player/anm.builder.js" type="text/javascript"></script>
		<script src="../player/animatron_import.js" type="text/javascript"></script>

		<script type="text/javascript">
			var b = Builder._$, B = Builder, C = anm.C;
			
			// canvas
			var width = 640;
			var height = 480;
			
			var scene = b();
			var main = b();
			var discs = b();
			var health;
			
			var points = 3;
			var wave = 0;
			var waveCount = 0;
			var nextSpawn = 1;
			var spawnCount = 0;
			var lastRound = 0;
			var nextRound = 1;
			
			var range = 72;
			var maxLevel = 5;
			var precision = 16;
			
			var spawn = [400, 400];
			var target = [0, 0];
			
			var mouse = [0, 0];
			
			var path;
			
			function Rectangle(x1, y1, x2, y2) {
				this.x1 = x1;
				this.y1 = y1;
				this.x2 = x2;
				this.y2 = y2;
			}
			
			var block = [new Rectangle(48, 0, 128, 160)]; // this will be preset, arrays of rectangles
			var enemy = new Array();
			var turret = new Array();
			var grid = new Array(); // height vs width
			
			// create grid
			grid = new Array(height/precision);
			for (var i=0; i<height/precision; i++) {
				grid[i] = new Array(width/precision);
				for (var j=0; j<width/precision; j++)
					grid[i][j] = 0;
			}
			// fill with blocks
			for (var i=0; i<block.length; i++) {
				var k = block[i];
				for (var y=k.y1/precision; y<k.y2/precision; y++) {
					for (var x=k.x1/precision; x<k.x2/precision; x++)
						grid[y][x] = 1;
				}
			}
			
			// A* implementation based on http://webreflection.blogspot.com/2006/10/javascript-path-finder-with-star.html
			
			function successors(x, y, rows, cols){
				var
					N = y - 1,
					S = y + 1,
					E = x + 1,
					W = x - 1,
					$N = N > -1 && !grid[N][x],
					$S = S < rows && !grid[S][x],
					$E = E < cols && !grid[y][E],
					$W = W > -1 && !grid[y][W],
					result = [],
					i = 0
				;
				$N && (result[i++] = {x:x, y:N});
				$E && (result[i++] = {x:E, y:y});
				$S && (result[i++] = {x:x, y:S});
				$W && (result[i++] = {x:W, y:y});
				return result;
			}
			
			function distanceTo(start, end) {
				// divide weight by turret distance
				var risk = 1;
				if (turret.length > 0)
				for (var i=0; i<turret.length; i++) {
					var d = turret[i].data();
					var r = Math.sqrt(Math.pow(precision*start.x - d.x, 2) + Math.pow(precision*start.y - d.y, 2));
					if (r <= range)
						risk *= 1 + (range - r)/range;
				}
				//console.log(turret.length, "("+start.x+", "+start.y+")", "("+end.x+", "+end.y+")", risk, r);
        		return (Math.abs(start.x - end.x) + Math.abs(start.y - end.y)) * risk;
    		}
					
			function AStar(start, end) {
				var
					cols = grid[0].length,
					rows = grid.length,
					limit = cols * rows,
					list = {},
					result = [],
					open = [{x:start[0], y:start[1], f:0, g:0, v:start[0]+start[1]*cols}],
					length = 1,
					adj, distance, i, j, max, min, current, next
				;
				end = {x:end[0], y:end[1], v:end[0]+end[1]*cols};
				
				do {
					max = limit;
					min = 0;
					for(i = 0; i < length; ++i) {
						if((f = open[i].f) < max) {
							max = f;
							min = i;
						}
					};
					current = open.splice(min, 1)[0];
					if (current.v != end.v) {
						--length;
						next = successors(current.x, current.y, grid, rows, cols);
						for(i = 0, j = next.length; i < j; ++i){
							(adj = next[i]).p = current;
							adj.f = adj.g = 0;
							adj.v = adj.x + adj.y * cols;
							if(!(adj.v in list)){
								adj.f = (adj.g = current.g + distanceTo(adj, current)) + distanceTo(adj, end);
								open[length++] = adj;
								list[adj.v] = 1;
							}
						}
					} else {
						i = length = 0;
						do {
							result[i++] = [current.x, current.y];
						} while (current = current.p);
						result.reverse();
					}
				} while (length);
				return result;
			}
			
			function healthBars() {
				var w = 16;
				var h = 2;
				var o = 32;
				return b().paint(function(ctx) {
					for (var i=0; i<enemy.length; i++) {
						var d = enemy[i].data();
						ctx.strokeStyle = '#000';
						ctx.strokeRect(d.x, d.y - o, w, h);
						var fx = d.hp*w/d.mhp;
						ctx.fillStyle = '#0f0';
						ctx.fillRect(d.x, d.y - o, fx, h);
						ctx.fillStyle = '#f00';
						ctx.fillRect(d.x + fx, d.y - o, w - fx, h);
					}
				});
			}
			
			var mainModifer = function(t) {
				//console.log(t, nextRound, wave);
				var rate = 2/3;
				if (t >= nextRound) {
					waveCount = Math.floor(19.1*Math.atan(wave/10));
					currentRound = nextRound;
					spawnCount = 0;
					nextRound += 4*Math.sqrt(2*waveCount);
					wave++;
				}
				if (t >= nextSpawn) {
					if (spawnCount < waveCount) {
						// spawn enemy
						path = AStar([Math.floor(spawn[0]/precision), Math.floor(spawn[1]/precision)], target);
						main.add(initEnemy(spawn[0], spawn[1]));
						nextSpawn += Math.min(1, rate*(nextRound - currentRound)/waveCount);
						spawnCount++;
					} else
						nextSpawn = nextRound;
				}
			}
			
			var enemyModifier = function(t) {
				var speed = 1;
				var d = b(this.$).data();
				var x = d.x;
				var y = d.y;
				var index = d.i + speed/precision;
				var p = d.path;
				var i = Math.ceil(index);
				if (i < p.length) {
					var xdif = p[i][0]*precision - x;
					var ydif = p[i][1]*precision - y;
					this.x = x + (xdif < 0 ? -1 : xdif > 0 ? 1 : 0)*speed;
					this.y = y + (ydif < 0 ? -1 : ydif > 0 ? 1 : 0)*speed;
					b(this.$).data({'x':this.x, 'y':this.y, 'i':index, 'path':p, 'mhp':d.mhp, 'hp':d.hp});
					//console.log(index, this.x, this.y);
				}
			}
			
			var turretModifier = function(t) {
				var d = b(this.$).data();
				var nt = d.t;
				if (t - d.t >= 2/d.level && enemy.length > 0) {
					// find nearest
					var e = null;
					var f = width * height * width * height;
					for (var i=0; i<enemy.length; i++) {
						var g = Math.sqrt(Math.pow(enemy[i].data().x - d.x, 2) + Math.pow(enemy[i].data().y - d.y, 2));
						if (g < f && g <= range) {
							f = g;
							e = enemy[i];
						}
					}
					if (e != null) {
						var a = Math.atan2(e.data().y - d.y + precision/2, e.data().x - d.x + precision/2);
						main.add(initBullet(d.x, d.y, Math.cos(a), Math.sin(a)));
					}
					nt = t;
				}
				b(this.$).data({'x':d.x, 'y':d.y, 'level':d.level, 't':nt});
			}
			
			var bulletModifier = function(t) {
				var d = b(this.$).data();
				this.x = d.x + d.vx;
				this.y = d.y + d.vy;
				for (var i=0; i<enemy.length; i++) {
					if (this.$.intersects(enemy[i].v)) {
						main.remove(this.$);
						// damage other
						var e = enemy[i].data();
						//console.log(i, "hp at", e.hp - d.damage);
						if (e.hp - d.damage > 0)
							enemy[i].data({'x':e.x, 'y':e.y, 'i':e.i, 'path':e.path, 'mhp':e.mhp, 'hp':e.hp - d.damage});
						else {
							main.remove(enemy[i]);
							enemy.splice(i, 1);
							i--;
							// add points
							points++;
						}
					}
				}
				if (this.x <= -2 || this.y <= -2 || this.x >= width+2 || this.y >= height+2)
					main.remove(this.$);
				b(this.$).data({'x':this.x, 'y':this.y, 'vx':d.vx, 'vy':d.vy, 'damage':d.damage});
			}
			
			function initEnemy(xi, yi) {
				var t = b().rect([precision/2, precision/2], [precision, precision]).fill('#000').data({'x':xi, 'y':yi, 'mhp':3, 'hp':3, 'path':path, 'i':0}).modify(enemyModifier);
				enemy.push(t);
				return t;
			}
			
			function initTurret(xi, yi, l) {
				var c = b().circle([xi, yi], range).fill('#f80').nostroke().modify(function(t) {
					if (Math.sqrt(Math.pow(mouse[0]-xi, 2) + Math.pow(mouse[1]-yi, 2)) <= range)
						this.alpha = .5;
					else
						this.alpha = 0;
				});
				var t = b().circle([xi, yi], precision/2).fill('#f00').nostroke().data({'x':xi, 'y':yi, 'level':l, 'disc':c, 't':0}).modify(turretModifier);
				discs.add(c);
				turret.push(t);
				return t;
			}
			
			function initBullet(xi, yi, vx, vy, d) {
				var t = b().circle([0, 0], 2).fill('#00f').nostroke().data({'x':xi, 'y':yi, 'vx':vx, 'vy':vy, 'damage':1}).modify(bulletModifier);
				return t;
			}
			
            function start() {
				//path = AStar([Math.floor(spawn[0]/precision), Math.floor(spawn[1]/precision)], target);
				//main.add(initEnemy(spawn[0], spawn[1]));
				
				main.on(C.X_MCLICK, function(evt) {
					if (points > 0) {
						var x = Math.round((evt.pos[0] - precision/2)/precision)*precision + precision/2;
						var y = Math.round((evt.pos[1] - precision/2)/precision)*precision + precision/2;
						
						// make physical (somewhat)
						grid[Math.round((evt.pos[1] - precision/2)/precision)][Math.round((evt.pos[0] - precision/2)/precision)] = 1;
						
						var same = -1;
						for (var i=0; i<turret.length; i++) {
							var d = turret[i].data();
							if (x == d.x && y == d.y) {
								same = i;
								break;
							}
						}
						
						if (same == -1) {
							main.add(initTurret(x, y, 1));
						} else {
							var d = turret[same].data();
							if (d.level < maxLevel)
								turret[same].data({'x':d.x, 'y':d.y, 'level':d.level+1, 't':d.t});
							else
								points++;
						}
						
						points--;
						
						//test code
						//path = AStar([Math.floor(spawn[0]/precision), Math.floor(spawn[1]/precision)], target);
						//main.add(initEnemy(spawn[0], spawn[1]));
					}
				}).on(C.X_MMOVE, function(evt) {
					mouse = evt.pos;
				}).modify(mainModifer);
				
				health = healthBars();
				
				scene.add(main);
				scene.add(discs);
				scene.add(health);
				
				createPlayer('canvas', {'mode': C.M_DYNAMIC}).load(scene).play();
            }
        </script>
      </head>

	<body onload="start();">
		<h1>Tower Defense - Animatron HTML5 Player Demo</h1>

		<!-- canvases -->
		<canvas id="canvas" width="640" height="480"></canvas>

	</body>

</html>